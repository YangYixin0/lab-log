# 视频时间戳水印优化设计文档

## 一、需求背景

### 1.1 当前问题

Android Camera App 在视频采集时使用点阵字体（bitmap font）绘制时间戳水印，目的是辅助后续视觉大模型的分析。然而，现有的点阵字体存在以下问题：

- 字体外观不够美观，缺乏专业性
- 担心视觉大模型识别准确率不够高

### 1.2 优化目标

使用 OCR-B 字体替代现有点阵字体，通过字体渲染器生成高质量字符位图用于水印叠加，以提高：

- 水印视觉质量
- 大模型识别准确率

### 1.3 字体资源

- 字体文件路径：`/root/lab-log/android-camera/app/src/main/assets/fonts/OCRB_Regular.ttf`
- OCR-B 字体特点：专为光学字符识别设计的标准字体，具有高可读性和机器识别友好性

## 二、功能需求

### 2.1 字符位图渲染

**需求描述**

创建一个字体渲染模块，能够从 OCR-B TrueType 字体文件中渲染指定字符的位图。

**关键参数**

| 参数名称 | 说明 | 约束条件 |
|---------|------|----------|
| 字符尺寸 | 字符位图的像素尺寸 | 默认 16×24 像素 |
| 宽高比限制 | 字符宽高比例 | 固定为 4:6（即 width:height = 2:3） |
| 支持字符集 | 需要渲染的字符范围 | 数字 0-9、冒号、空格、字母 T/i/m/e |
| 可配置性 | 支持编译前配置不同尺寸 | 例如 12×18、20×30 等，但必须保持 4:6 比例 |

**输出格式**

- 单色位图数组（二维 IntArray）
- 像素值：1 表示白色（前景），0 表示透明/背景
- 数组结构：`Array<IntArray>`，外层数组索引为行（Y 坐标），内层数组索引为列（X 坐标）

### 2.2 字符位图预加载与缓存

**需求描述**

在应用启动时预先渲染所有时间戳所需字符的位图，避免运行时渲染开销。

**预加载策略**

| 策略类型 | 触发时机 | 说明 |
|---------|---------|------|
| 应用启动时预加载 | ViewModel 初始化时 | 在后台线程预先渲染所有需要的字符并缓存 |
| 同步阻塞预加载 | 应用启动完成前 | 确保首次绘制水印时所有字符已就绪 |

**预加载字符集**

- 数字：0 1 2 3 4 5 6 7 8 9
- 符号：:（冒号）、空格
- 字母：T i m e
- 总计：13 个字符

**缓存内容**

- 当前配置尺寸下所有预加载字符的位图
- 字符键值：Char → Array<IntArray>

### 2.3 水印绘制集成

**需求描述**

将渲染的字符位图集成到现有的时间戳水印绘制流程中，替换原有的硬编码点阵字体。

**集成点**

- 函数：`drawTimestampOnNv12()`
- 调用位置：`ImageProxy.toNv12ByteArray()` 函数中
- 绘制目标：NV12 格式的 Y 平面（亮度通道）

**绘制要求**

- 保持现有绘制逻辑（黑色背景 + 白色文字）
- 保持现有位置（左上角偏移可配置，默认 (10, 10)）
- 支持时间戳格式："Time: hh:mm:ss"（24 小时制）

### 2.4 编译时配置

**需求描述**

支持在编译前通过修改配置变量来切换字符尺寸。

**配置方式**

- 配置位置：`WebSocketViewModel` 类内部
- 配置变量示例：
  - `CHAR_WIDTH = 16`
  - `CHAR_HEIGHT = 24`
- 验证机制：编译时检查 `CHAR_WIDTH:CHAR_HEIGHT = 4:6` 是否成立

**可选尺寸示例**

| 宽度 | 高度 | 比例验证 |
|-----|------|---------|
| 12 | 18 | 12:18 = 2:3 ✓ |
| 16 | 24 | 16:24 = 2:3 ✓ |
| 20 | 30 | 20:30 = 2:3 ✓ |
| 24 | 36 | 24:36 = 2:3 ✓ |

## 三、技术方案

### 3.1 整体架构

```
┌─────────────────────────────────────────────────────┐
│                  WebSocketViewModel                 │
│  - timestampMode: Int (编译时配置)                  │
│  - getTimestampCharWidth(): Int                     │
│  - getTimestampCharHeight(): Int                    │
└─────────────────────┬───────────────────────────────┘
                      │
                      │ 配置参数传递
                      ↓
┌─────────────────────────────────────────────────────┐
│              OcrBFontRenderer (新增)                │
│  - loadTypeface(): Typeface                        │
│  - renderCharBitmap(char, width, height): Array    │
│  - getCachedCharBitmap(char): Array                │
└─────────────────────┬───────────────────────────────┘
                      │
                      │ 提供字符位图
                      ↓
┌─────────────────────────────────────────────────────┐
│          drawTimestampOnNv12() (改造)               │
│  - 替换 TimestampFont 调用为 OcrBFontRenderer      │
│  - 保持原有绘制逻辑                                 │
└─────────────────────────────────────────────────────┘
```

### 3.2 字体渲染模块设计

#### 3.2.1 模块职责

| 职责 | 说明 |
|-----|------|
| 字体加载 | 从 Assets 加载 OCR-B TrueType 字体文件 |
| 位图渲染 | 使用 Android Canvas + Paint 将字符渲染为单色位图 |
| 位图缓存 | 缓存已渲染的字符位图，避免重复计算 |
| 接口提供 | 对外提供获取字符位图的统一接口 |

#### 3.2.2 关键接口

**字体加载**

- 输入：Context（用于访问 AssetManager）
- 输出：Typeface 对象
- 异常处理：字体文件不存在时回退到系统等宽字体

**字符渲染**

- 输入：
  - char: Char（需要渲染的字符）
  - width: Int（目标宽度）
  - height: Int（目标高度）
- 输出：Array<IntArray>（位图数组，1 表示白色像素，0 表示背景）
- 渲染策略：
  - 使用 Bitmap.Config.ALPHA_8 创建临时位图
  - Paint 设置为 ANTI_ALIAS（抗锯齿）以提升渲染质量
  - 自动计算字体大小以充分填充目标尺寸
  - 字符居中绘制

**位图缓存**

- 数据结构：`Map<Char, Array<IntArray>>`
- 缓存键：字符（Char）
- 缓存值：渲染后的位图数组
- 缓存时机：懒加载（首次使用时渲染并缓存）

#### 3.2.3 渲染流程

```
[字符输入] 
    ↓
[检查缓存] ──存在──→ [返回缓存位图]
    ↓
   不存在
    ↓
[创建临时 Bitmap (ALPHA_8 格式)]
    ↓
[配置 Paint (抗锯齿、字体、居中对齐)]
    ↓
[计算合适的字体大小]
    ↓
[在 Canvas 上绘制字符]
    ↓
[从 Bitmap 提取像素数据]
    ↓
[转换为二维位图数组 (0/1)]
    ↓
[缓存位图数组]
    ↓
[返回位图数组]
```

### 3.3 字符尺寸自适应策略

#### 3.3.1 字体大小计算

**目标**

使渲染的字符能够充分填充目标尺寸（width × height），同时保证字符完整且居中。

**计算方法**

| 步骤 | 说明 |
|-----|------|
| 1. 初始字体大小 | 设置为目标高度的 80%-90%（例如 24px 高度使用 20-22px 字体） |
| 2. 试探性测量 | 使用 Paint.measureText() 和 Paint.getFontMetrics() 测量渲染尺寸 |
| 3. 尺寸调整 | 根据测量结果微调字体大小，确保不超出目标区域 |
| 4. 居中定位 | 计算绘制起点，使字符在目标区域内水平和垂直居中 |

**伪逻辑描述**

1. 初始字体大小 = 目标高度 × 0.85
2. 测量字符的实际渲染宽度和高度
3. 如果渲染宽度 > 目标宽度，缩小字体直到宽度适配
4. 如果渲染高度 > 目标高度，缩小字体直到高度适配
5. 计算 X 偏移 = (目标宽度 - 渲染宽度) / 2
6. 计算 Y 偏移 = (目标高度 + 字体基线高度) / 2
7. 在 (X偏移, Y偏移) 位置绘制字符

### 3.4 水印绘制流程改造

#### 3.4.1 现有流程分析

**当前实现**（基于硬编码点阵字体）

| 步骤 | 现有实现 |
|-----|---------|
| 字符位图获取 | `TimestampFont.getCharBitmap12x18(char)` 或 `getCharBitmap16x24(char)` |
| 位图来源 | 硬编码的 IntArray 二维数组（静态常量） |
| 支持字符 | 数字 0-9、冒号、空格、T/i/m/e |
| 绘制逻辑 | 逐像素检查位图值，值为 1 时在 NV12 的 Y 平面写入 255（白色） |

#### 3.4.2 改造方案

**替换字符位图来源**

- 移除：`TimestampFont.getCharBitmap12x18()` / `getCharBitmap16x24()`
- 替换为：`OcrBFontRenderer.getCachedCharBitmap(char, width, height)`

**保持不变部分**

- 绘制黑色背景矩形的逻辑
- 逐字符、逐像素绘制的循环结构
- NV12 Y 平面像素值设置（0 表示黑色，255 表示白色）
- 偏移量、间距、边距的计算

**修改对比**

| 项目 | 修改前 | 修改后 |
|-----|-------|-------|
| 字符位图获取 | 从静态常量数组获取 | 从渲染器缓存获取 |
| 字符质量 | 简单点阵，边缘锯齿 | TrueType 渲染，抗锯齿平滑 |
| 字符尺寸配置 | 硬编码 12×18 和 16×24 两种 | 编译时可配置任意 4:6 比例尺寸 |
| 新增字符支持 | 需要手动绘制点阵数组 | 字体自动支持所有字符 |

### 3.5 兼容性与异常处理

#### 3.5.1 字体加载失败处理

**异常场景**

- OCR-B 字体文件不存在或路径错误
- 字体文件损坏无法解析
- AssetManager 访问权限问题

**处理策略**

| 优先级 | 处理方案 | 说明 |
|-------|---------|------|
| 1 | 使用系统等宽字体 | Typeface.MONOSPACE（Android 内置） |
| 2 | 无水印模式 | 跳过水印绘制，仅记录错误日志 |

**实现方式**

- 在字体加载时捕获异常
- 记录错误日志（Log.e）
- 优先尝试使用 Typeface.MONOSPACE 继续执行
- 若系统字体也失败，则完全禁用水印功能
- 通过状态消息向用户显示警告信息（"水印功能不可用"）

#### 3.5.2 渲染性能监控

**潜在风险**

- 字体渲染可能增加首帧延迟
- 大量字符缓存可能占用内存

**监控指标**

| 指标名称 | 监控方法 | 阈值建议 |
|---------|---------|---------|
| 首次渲染耗时 | 时间戳记录渲染前后时间差 | < 50ms（单个字符） |
| 缓存内存占用 | 计算缓存 Map 大小 | < 100KB（约 20 个字符） |
| 帧处理延迟 | 编码前后时间差 | 不增加超过 5ms |

**优化措施**

- 懒加载：仅在首次使用时渲染字符
- 预加载（可选）：应用启动时后台预渲染常用字符（0-9、冒号）
- 内存限制：仅缓存时间戳所需的 13 个字符（"Time: hh:mm:ss"）

## 四、数据模型

### 4.1 字符位图数据结构

**类型定义**

```
字符位图 = Array<IntArray>
  - 外层数组：行（Y 坐标），长度 = charHeight
  - 内层数组：列（X 坐标），长度 = charWidth
  - 像素值：Int，取值 0 或 1
    - 0：背景/透明
    - 1：前景/白色
```

**内存估算**

| 尺寸 | 单个字符内存 | 13 个字符总内存 |
|-----|------------|----------------|
| 12×18 | 216 × 4 bytes = 864 bytes | ~11 KB |
| 16×24 | 384 × 4 bytes = 1536 bytes | ~20 KB |
| 20×30 | 600 × 4 bytes = 2400 bytes | ~31 KB |

### 4.2 配置参数模型

**时间戳模式枚举**

| 模式常量 | 数值 | 字符尺寸 | 说明 |
|---------|-----|---------|------|
| TIMESTAMP_MODE_NONE | 0 | - | 不绘制时间戳 |
| TIMESTAMP_MODE_OCRB_12x18 | 1 | 12×18 | OCR-B 字体小尺寸 |
| TIMESTAMP_MODE_OCRB_16x24 | 2 | 16×24 | OCR-B 字体默认尺寸 |
| TIMESTAMP_MODE_OCRB_20x30 | 3 | 20×30 | OCR-B 字体大尺寸 |

**配置参数表**

| 参数名称 | 类型 | 默认值 | 说明 |
|---------|-----|-------|------|
| timestampMode | Int | TIMESTAMP_MODE_OCRB_16x24 | 当前水印模式 |
| charWidth | Int | 16 | 字符宽度（像素） |
| charHeight | Int | 24 | 字符高度（像素） |
| fontAssetPath | String | "fonts/OCRB Regular.ttf" | 字体文件相对路径 |

## 五、接口定义

### 5.1 字体渲染器接口

**对象：OcrBFontRenderer**

| 方法名称 | 输入参数 | 输出 | 说明 |
|---------|---------|------|------|
| initialize | context: Context | Unit | 初始化渲染器，加载字体 |
| getCachedCharBitmap | char: Char, width: Int, height: Int | Array<IntArray>? | 获取字符位图（带缓存） |
| renderCharBitmap | char: Char, width: Int, height: Int | Array<IntArray> | 渲染字符位图（内部方法） |
| clearCache | - | Unit | 清空缓存（用于内存管理） |

### 5.2 水印绘制接口改造

**函数：drawTimestampOnNv12**

**修改前签名**

- 参数：nv12: ByteArray, width: Int, height: Int, timestamp: String, charWidth: Int, charHeight: Int, offsetX: Int, offsetY: Int
- 内部调用：TimestampFont.getCharBitmap12x18() / getCharBitmap16x24()

**修改后签名**

- 参数：保持不变
- 内部调用：OcrBFontRenderer.getCachedCharBitmap(char, charWidth, charHeight)

**行为变化**

| 调用场景 | 修改前 | 修改后 |
|---------|-------|-------|
| 字符存在于字体 | 返回硬编码点阵 | 返回预渲染的 OCR-B 位图（从缓存） |
| 字符不存在于字体 | 返回 null | 返回 null |
| 首次调用字符 | 立即返回 | 从预加载缓存返回（启动时已渲染） |
| 后续调用相同字符 | 立即返回 | 从缓存立即返回 |

## 六、流程设计

### 6.1 应用启动与预加载流程

```
[应用启动]
    ↓
[WebSocketViewModel 初始化]
    ↓
[读取 timestampMode 配置]
    ↓
[启动后台协程]
    ↓
[OcrBFontRenderer.initialize(context)] ──失败──→ [记录错误，尝试系统字体]
    ↓                                              ↓
   成功                                      [Typeface.MONOSPACE]
    ↓                                              ↓
[字体加载完成]                                   [系统字体加载]
    ↓                                              ↓
[预渲染所有字符]                          [预渲染所有字符（系统字体）]
    ↓                                              ↓
    └──────────────────┬───────────────────────────┘
                       ↓
              [所有字符缓存完成]
                       ↓
              [设置预加载完成标志]
                       ↓
                  [应用就绪]
```

### 6.2 视频帧水印绘制流程

```
[CameraX 输出 ImageProxy]
    ↓
[toNv12ByteArray() 调用]
    ↓
[YUV → NV12 转换（含旋转）]
    ↓
[检查是否需要绘制时间戳]
    ↓ (timestampMode != NONE)
    ↓
[获取当前时间戳字符串] "Time: hh:mm:ss"
    ↓
[调用 drawTimestampOnNv12()]
    ↓
[检查预加载完成标志]
    ↓          ↓
  已完成    未完成
    ↓          ↓
  继续    [跳过水印绘制，返回原数据]
    ↓
[绘制黑色背景矩形于 Y 平面]
    ↓
[遍历时间戳字符串中的每个字符]
    ↓
    ┌──────────────────────┐
    │ 对于每个字符 char:    │
    │   ↓                  │
    │ [OcrBFontRenderer.   │
    │  getCachedCharBitmap │
    │  (char)]             │
    │   ↓                  │
    │ [从缓存获取位图]     │
    │   ↓                  │
    │ [逐像素绘制到 NV12]  │
    │   ↓                  │
    │ [字符偏移量 += w]    │
    └──────────────────────┘
    ↓
[返回带水印的 NV12 数据]
    ↓
[送入 H264Encoder 编码]
```

### 6.3 字符预渲染详细流程

```
[preloadAllCharacters(width, height)]
    ↓
[获取需要预加载的字符集]
    "0123456789: Time"
    ↓
[遍历每个字符]
    ↓
    ┌─────────────────────────────┐
    │ 对于每个字符 char:           │
    │   ↓                         │
    │ [renderCharBitmap(char,     │
    │  width, height)]            │
    │   ↓                         │
    │ [创建 Bitmap (width×height, │
    │  ALPHA_8)]                  │
    │   ↓                         │
    │ [创建 Canvas(bitmap)]       │
    │   ↓                         │
    │ [配置 Paint]                │
    │   - typeface = ocrBTypeface │
    │   - textSize = height × 0.85│
    │   - isAntiAlias = true      │
    │   - textAlign = CENTER      │
    │   ↓                         │
    │ [测量字符实际渲染尺寸]      │
    │   ↓                         │
    │ [调整字体大小以适配目标尺寸]│
    │   ↓                         │
    │ [计算居中绘制坐标]          │
    │   ↓                         │
    │ [canvas.drawText(char,      │
    │  x, y, paint)]              │
    │   ↓                         │
    │ [从 Bitmap 提取像素数据]    │
    │   ↓                         │
    │ [转换为二维 IntArray]       │
    │   - 像素 Alpha > 128 → 1    │
    │   - 像素 Alpha ≤ 128 → 0    │
    │   ↓                         │
    │ [缓存到 Map]                │
    │   ↓                         │
    │ [回收临时 Bitmap]           │
    └─────────────────────────────┘
    ↓
[所有字符预渲染完成]
    ↓
[设置预加载完成标志 = true]
```

## 七、异常处理

### 7.1 字体加载异常

| 异常类型 | 原因 | 处理策略 |
|---------|------|---------|
| FileNotFoundException | 字体文件路径错误或不存在 | 使用 Typeface.MONOSPACE，记录错误日志 |
| RuntimeException | 字体文件格式损坏 | 使用 Typeface.MONOSPACE，记录错误日志 |
| SecurityException | 无权限访问 Assets | 使用 Typeface.MONOSPACE，记录错误日志 |

### 7.2 渲染异常

| 异常类型 | 原因 | 处理策略 |
|---------|------|---------|
| OutOfMemoryError | 位图创建失败（尺寸过大） | 跳过该字符，返回 null，记录错误 |
| IllegalArgumentException | 无效的字符尺寸（width/height ≤ 0） | 使用默认尺寸（16×24），记录警告 |
| NullPointerException | Canvas 或 Paint 初始化失败 | 返回 null，降级到无水印模式 |

### 7.3 绘制异常

| 异常类型 | 原因 | 处理策略 |
|---------|------|---------|
| ArrayIndexOutOfBoundsException | 水印绘制超出 NV12 数组边界 | 提前边界检查，裁剪水印区域 |
| NullPointerException | 字符位图为 null（预加载失败） | 跳过水印绘制，返回原数据 |
| IllegalStateException | 预加载未完成就开始绘制 | 跳过水印绘制，记录警告日志 |

### 7.4 日志记录规范

| 日志级别 | 使用场景 | 日志标签 |
|---------|---------|---------|
| Log.d | 字体加载成功、缓存命中 | TAG = "OcrBFontRenderer" |
| Log.w | 回退到备用字体、字符渲染失败 | TAG = "OcrBFontRenderer" |
| Log.e | 字体加载失败、严重渲染错误 | TAG = "OcrBFontRenderer" |

## 八、性能优化

### 8.1 渲染性能优化

| 优化项 | 具体措施 | 预期收益 |
|-------|---------|---------|
| 启动时预加载 | 在后台线程一次性渲染所有字符 | 运行时零渲染开销 |
| 缓存复用 | 使用 Map 缓存预渲染字符 | 绘制帧直接读取缓存 |
| 批量渲染优化 | 共享 Paint 和 Canvas 配置 | 减少对象创建开销 |
| 抗锯齿控制 | 使用 ANTI_ALIAS，但避免过度平滑 | 平衡质量与性能 |
| 位图格式优化 | 使用 ALPHA_8（单通道 8 位）而非 ARGB_8888 | 内存占用减少 75% |

### 8.2 内存优化

| 优化项 | 具体措施 | 预期收益 |
|-------|---------|---------|
| 限制缓存字符集 | 仅缓存时间戳所需的 13 个字符 | 内存占用 < 50KB |
| 及时释放临时对象 | 渲染后立即回收临时 Bitmap | 减少 GC 压力 |
| 弱引用缓存（可选） | 内存紧张时允许 GC 回收缓存 | 避免 OOM 风险 |

### 8.3 帧率影响评估

| 场景 | 原实现耗时 | 新实现耗时 | 差异 |
|-----|----------|-----------|------|
| 应用启动预加载 | 0ms（无预加载） | ~100-200ms（后台线程） | 不影响主线程 |
| 首次绘制水印 | ~1ms（硬编码数组访问） | ~1ms（缓存命中） | 无差异 |
| 后续帧绘制水印 | ~1ms | ~1ms（缓存命中） | 无差异 |
| 无水印模式 | 0ms | 0ms | 无差异 |

**结论**：预加载在后台线程完成，不影响主线程和帧率；运行时性能与原实现相同。

## 九、测试验证

### 9.1 功能测试

| 测试项 | 测试方法 | 验收标准 |
|-------|---------|---------|
| 字体加载 | 启动应用，检查日志 | 成功加载 OCR-B 字体，无错误日志 |
| 字符渲染质量 | 录制视频，截图放大查看时间戳 | 字符边缘平滑，无明显锯齿，字形清晰 |
| 时间戳正确性 | 对比系统时间与视频水印时间 | 时间戳准确，格式正确（"Time: hh:mm:ss"） |
| 不同尺寸配置 | 编译前修改 charWidth/charHeight | 水印尺寸按配置变化，比例保持 4:6 |

### 9.2 兼容性测试

| 测试项 | 测试场景 | 验收标准 |
|-------|---------|---------|
| 字体文件缺失 | 删除或重命名字体文件 | 自动回退到系统字体，应用不崩溃 |
| 字体文件损坏 | 使用损坏的 TTF 文件 | 捕获异常，回退到备用方案，记录错误日志 |
| 低内存设备 | 在内存受限设备上运行 | 缓存正常工作，无 OOM 崩溃 |
| 不同 Android 版本 | API 24-36 设备测试 | 所有版本均正常渲染水印 |

### 9.3 性能测试

| 测试项 | 测试方法 | 验收标准 |
|-------|---------|---------|
| 启动时预加载耗时 | 时间戳记录预加载总耗时 | < 200ms（13 个字符总耗时） |
| 启动延迟影响 | 对比开启/关闭预加载的启动时间 | 启动延迟增加 < 300ms |
| 帧率影响 | 对比开启/关闭水印的帧率 | 无影响（缓存已就绪） |
| 内存占用 | 使用 Profiler 监控缓存内存 | 缓存占用 < 50KB |
| CPU 占用 | 录制过程中监控 CPU 使用率 | 无增加（无运行时渲染） |

### 9.4 视觉识别测试

| 测试项 | 测试方法 | 验收标准 |
|-------|---------|---------|
| OCR 识别准确率 | 使用 Tesseract/PaddleOCR 识别水印 | 识别准确率 > 95% |
| 大模型识别 | 提交视频给 GPT-4V/Claude 等模型 | 模型能准确读取时间戳信息 |
| 不同光照条件 | 在明亮/昏暗环境录制视频 | 所有条件下水印清晰可辨 |
| 不同背景复杂度 | 录制简单/复杂背景场景 | 黑色背景确保水印始终可见 |

## 十、实施计划

### 10.1 代码模块划分

| 模块名称 | 文件位置 | 主要内容 |
|---------|---------|---------|
| 字体渲染器 | MainActivity.kt（新增 OcrBFontRenderer 对象） | 字体加载、字符渲染、缓存管理 |
| 配置管理 | MainActivity.kt（WebSocketViewModel 修改） | 时间戳模式枚举、尺寸配置变量 |
| 水印绘制 | MainActivity.kt（drawTimestampOnNv12 改造） | 替换字符位图来源，保持绘制逻辑 |
| 字体资源 | app/src/main/assets/fonts/OCRB Regular.ttf | OCR-B 字体文件（需确认存在） |

### 10.2 实施步骤

| 步骤 | 任务内容 | 预计工作量 |
|-----|---------|-----------|
| 1 | 确认字体文件存在于 assets/fonts 目录 | 0.1 小时 |
| 2 | 创建 OcrBFontRenderer 对象，实现字体加载逻辑 | 1 小时 |
| 3 | 实现 renderCharBitmap() 方法（Canvas 渲染） | 2 小时 |
| 4 | 实现预加载机制（后台协程 + 批量渲染） | 1 小时 |
| 5 | 改造 drawTimestampOnNv12() 函数（移除 TimestampFont） | 1 小时 |
| 6 | 添加配置变量和模式枚举 | 0.5 小时 |
| 7 | 添加异常处理（无原点阵字体回退） | 0.5 小时 |
| 8 | 移除原 TimestampFont 相关代码 | 0.5 小时 |
| 9 | 单元测试（字符渲染、预加载完成） | 1 小时 |
| 10 | 集成测试（真机录制视频） | 1 小时 |
| 11 | 性能测试和优化（启动时间、内存） | 1 小时 |
| 12 | 文档更新（README 说明新字体和预加载） | 0.5 小时 |

**总计**：约 10.5 小时

### 10.3 风险与应对

| 风险 | 可能性 | 影响 | 应对措施 |
|-----|-------|------|---------|
| 字体文件不存在 | 中 | 高 | 实施前检查文件，若不存在则添加或使用其他 OCR 字体 |
| 渲染质量不佳 | 低 | 中 | 调整抗锯齿、字体大小计算算法，必要时手动微调 |
| 预加载增加启动时间 | 中 | 中 | 使用后台协程，优化批量渲染性能 |
| 预加载失败导致无水印 | 低 | 中 | 完善异常处理，回退到系统字体 |
| Android 版本兼容问题 | 低 | 低 | 多设备测试，针对性适配 |

## 十一、验收标准

### 11.1 功能完整性

- [ ] OCR-B 字体成功加载并应用于时间戳水印
- [ ] 支持编译时配置字符尺寸（默认 16×24）
- [ ] 水印绘制位置、样式与原实现一致
- [ ] 字体加载失败时自动回退到备用方案

### 11.2 质量要求

- [ ] 字符渲染边缘平滑，无明显锯齿
- [ ] 水印在各种背景下清晰可见
- [ ] 时间戳格式正确，时间准确

### 11.3 性能要求

- [ ] 启动时预加载耗时 < 200ms
- [ ] 启动延迟增加 < 300ms
- [ ] 运行时帧率无影响（缓存已就绪）
- [ ] 内存占用增加 < 50KB
- [ ] 运行时 CPU 占用无增加

### 11.4 识别准确率

- [ ] OCR 工具识别准确率 > 95%
- [ ] 大模型能准确读取时间戳信息

### 11.5 代码质量

- [ ] 代码符合 Kotlin 编码规范
- [ ] 关键逻辑有清晰注释
- [ ] 异常处理完善，日志记录规范
- [ ] README 文档更新字体相关说明

## 十二、后续优化方向

### 12.1 功能增强

| 优化项 | 说明 | 优先级 |
|-------|------|-------|
| 运行时动态切换字体 | 支持不重新编译切换字体尺寸 | 低 |
| 支持自定义字体 | 允许用户上传其他 TTF 字体 | 低 |
| 多种水印样式 | 支持不同颜色、阴影、描边效果 | 中 |
| 水印位置可配置 | 支持四角、中心等位置选择 | 中 |

### 12.2 性能优化

| 优化项 | 说明 | 优先级 |
|-------|------|-------|
| 预加载并行化 | 使用多线程并行渲染字符 | 中 |
| 使用 NDK 渲染 | 使用 C/C++ 实现渲染以提升性能 | 低 |
| GPU 加速 | 使用 RenderScript 或 OpenGL 渲染 | 低 |

### 12.3 智能化增强

| 优化项 | 说明 | 优先级 |
|-------|------|-------|
| 自适应对比度 | 根据背景亮度自动调整水印颜色 | 中 |
| 内容感知定位 | 避免水印遮挡重要内容区域 | 低 |
| 多语言支持 | 支持中文、日文等非拉丁字符 | 低 |

---

## 附录

### A. 字符集定义

**时间戳所需字符集**

```
数字：0 1 2 3 4 5 6 7 8 9
符号：:（冒号）
分隔：（空格）
前缀：T i m e
```

**总计**：13 个不同字符

### B. 4:6 比例尺寸参考

| 宽度 (px) | 高度 (px) | 比例验证 | 推荐场景 |
|----------|----------|---------|---------|
| 8 | 12 | 8:12 = 2:3 ✓ | 超小尺寸（低分辨率视频） |
| 12 | 18 | 12:18 = 2:3 ✓ | 小尺寸（720p 视频） |
| 16 | 24 | 16:24 = 2:3 ✓ | 默认尺寸（1080p 视频）⭐ |
| 20 | 30 | 20:30 = 2:3 ✓ | 大尺寸（1440p 视频） |
| 24 | 36 | 24:36 = 2:3 ✓ | 超大尺寸（4K 视频） |

### C. OCR-B 字体特性

**设计目的**

- ISO 1073/2 标准字体
- 专为光学字符识别（OCR）设计
- 人类和机器均易读

**字符特征**

- 等宽字体（Monospaced）
- 简洁笔画，无衬线
- 高对比度，边缘清晰
- 数字区分度高（如 0 与 O、1 与 I）

**识别优势**

- OCR 软件识别准确率高（> 99%）
- 大模型训练数据中常见
- 抗噪声能力强
- 在低分辨率下仍保持可读性

### D. Typeface 回退优先级

| 优先级 | 字体名称 | 来源 | 说明 |
|-------|---------|------|------|
| 1 | OCR-B Regular | Assets | 首选字体 |
| 2 | Typeface.MONOSPACE | Android 系统 | 系统内置等宽字体 |
| 3 | 无水印模式 | - | 完全禁用水印功能 |
